[33mcommit b9a0f9a850307ed1fa115e59b9499e6724e6dd30[m
Author: Ekko-Technology <joshyeo798@gmail.com>
Date:   Thu Mar 27 21:17:29 2025 +0800

    2nd commit

[1mdiff --git a/Alex.ino b/Alex.ino[m
[1mnew file mode 100644[m
[1mindex 0000000..d6dacf7[m
[1m--- /dev/null[m
[1m+++ b/Alex.ino[m
[36m@@ -0,0 +1,602 @@[m
[32m+[m[32m#include <math.h>[m
[32m+[m[32m#include <stdarg.h>[m
[32m+[m[32m#include <serialize.h>[m
[32m+[m
[32m+[m[32m#include "packet.h"[m
[32m+[m[32m#include "constants.h"[m
[32m+[m
[32m+[m[32m#define ALEX_LENGTH        26[m
[32m+[m[32m#define ALEX_BREADTH       15[m
[32m+[m
[32m+[m[32mfloat alexDiagonal = 0.0;[m
[32m+[m[32mfloat alexCirc = 0.0;[m
[32m+[m
[32m+[m[32mvolatile TDirection dir;[m
[32m+[m
[32m+[m[32m/*[m
[32m+[m[32m * Alex's configuration constants[m
[32m+[m[32m */[m
[32m+[m
[32m+[m[32m// Number of ticks per revolution from the[m[41m [m
[32m+[m[32m// wheel encoder.[m
[32m+[m
[32m+[m[32m#define COUNTS_PER_REV      4[m
[32m+[m
[32m+[m[32m// Wheel circumference in cm.[m
[32m+[m[32m// We will use this to calculate forward/backward distance traveled[m[41m [m
[32m+[m[32m// by taking revs * WHEEL_CIRC[m
[32m+[m
[32m+[m[32m#define WHEEL_CIRC          21[m
[32m+[m
[32m+[m[32m/*[m
[32m+[m[32m *    Alex's State Variables[m
[32m+[m[32m */[m
[32m+[m
[32m+[m[32m// Store the ticks from Alex's left and[m
[32m+[m[32m// right encoders.[m
[32m+[m[32mvolatile unsigned long leftForwardTicks;[m[41m [m
[32m+[m[32mvolatile unsigned long rightForwardTicks;[m
[32m+[m[32mvolatile unsigned long leftReverseTicks;[m[41m [m
[32m+[m[32mvolatile unsigned long rightReverseTicks;[m
[32m+[m
[32m+[m[32m// Left and right encoder ticks for turning[m
[32m+[m[32mvolatile unsigned long leftForwardTicksTurns;[m[41m [m
[32m+[m[32mvolatile unsigned long rightForwardTicksTurns;[m
[32m+[m[32mvolatile unsigned long leftReverseTicksTurns;[m[41m [m
[32m+[m[32mvolatile unsigned long rightReverseTicksTurns;[m
[32m+[m
[32m+[m[32m// Store the revolutions on Alex's left[m
[32m+[m[32m// and right wheels[m
[32m+[m[32mvolatile unsigned long leftRevs;[m
[32m+[m[32mvolatile unsigned long rightRevs;[m
[32m+[m
[32m+[m[32m// Forward and backward distance traveled[m
[32m+[m[32mvolatile unsigned long forwardDist;[m
[32m+[m[32mvolatile unsigned long reverseDist;[m
[32m+[m
[32m+[m[32munsigned long deltaDist;[m
[32m+[m[32munsigned long newDist;[m
[32m+[m[32munsigned long deltaTicks;[m
[32m+[m[32munsigned long targetTicks;[m
[32m+[m[32munsigned long targetRightTicks;[m
[32m+[m[32munsigned long targetLeftTicks;[m
[32m+[m
[32m+[m
[32m+[m[32mvoid fforward(float dist, float speed) {[m
[32m+[m[32m  if(dist > 0)[m
[32m+[m[32m    deltaDist = dist;[m
[32m+[m[32m  else[m
[32m+[m[32m    deltaDist=9999999;[m
[32m+[m[32m  newDist = forwardDist + deltaDist;[m
[32m+[m[32m  forward(dist, speed);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid reverse(float dist, float speed) {[m
[32m+[m[32m  if(dist > 0)[m
[32m+[m[32m    deltaDist = dist;[m
[32m+[m[32m  else[m
[32m+[m[32m    deltaDist=9999999;[m
[32m+[m[32m  newDist = reverseDist + deltaDist;[m
[32m+[m[32m  backward(dist, speed);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32munsigned long computeDeltaTicks(float ang){[m
[32m+[m[32m  unsigned long ticks = (unsigned long) ((ang * alexCirc * COUNTS_PER_REV) / (360.0 * WHEEL_CIRC));[m
[32m+[m[32m  return ticks;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid left(float ang, float speed) {[m
[32m+[m[32m  if(ang == 0)[m
[32m+[m[32m    deltaTicks=99999999;[m
[32m+[m[32m  else[m
[32m+[m[32m    deltaTicks=computeDeltaTicks(ang);[m
[32m+[m[32m  targetTicks = leftReverseTicksTurns + deltaTicks;[m
[32m+[m[32m  ccw(ang, speed);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid right(float ang, float speed) {[m
[32m+[m[32m  if(ang == 0)[m
[32m+[m[32m    deltaTicks=99999999;[m
[32m+[m[32m  else[m
[32m+[m[32m    deltaTicks=computeDeltaTicks(ang);[m
[32m+[m[32m  targetTicks = rightReverseTicksTurns + deltaTicks;[m
[32m+[m[32m  cw(ang, speed);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m/*[m
[32m+[m[32m *[m[41m [m
[32m+[m[32m * Alex Communication Routines.[m
[32m+[m[32m *[m[41m [m
[32m+[m[32m */[m
[32m+[m[41m [m
[32m+[m[32mTResult readPacket(TPacket *packet)[m
[32m+[m[32m{[m
[32m+[m[32m    // Reads in data from the serial port and[m
[32m+[m[32m    // deserializes it.Returns deserialized[m
[32m+[m[32m    // data in "packet".[m
[32m+[m[41m    [m
[32m+[m[32m    char buffer[PACKET_SIZE];[m
[32m+[m[32m    int len;[m
[32m+[m
[32m+[m[32m    len = readSerial(buffer);[m
[32m+[m
[32m+[m[32m    if(len == 0)[m
[32m+[m[32m      return PACKET_INCOMPLETE;[m
[32m+[m[32m    else[m
[32m+[m[32m      return deserialize(buffer, len, packet);[m
[32m+[m[41m    [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid sendStatus()[m
[32m+[m[32m{[m
[32m+[m[32m  // Implement code to send back a packet containing key[m
[32m+[m[32m  // information like leftTicks, rightTicks, leftRevs, rightRevs[m
[32m+[m[32m  // forwardDist and reverseDist[m
[32m+[m[32m  // Use the params array to store this information, and set the[m
[32m+[m[32m  // packetType and command files accordingly, then use sendResponse[m
[32m+[m[32m  // to send out the packet. See sendMessage on how to use sendResponse.[m
[32m+[m[32m  TPacket statusPacket;[m
[32m+[m[32m  statusPacket.packetType=PACKET_TYPE_RESPONSE;[m
[32m+[m[32m  statusPacket.command=RESP_STATUS;[m
[32m+[m[32m  statusPacket.params[0] = leftForwardTicks;[m
[32m+[m[32m  statusPacket.params[1] = rightForwardTicks;[m
[32m+[m[32m  statusPacket.params[2] = leftReverseTicks;[m
[32m+[m[32m  statusPacket.params[3] = rightReverseTicks;[m
[32m+[m[32m  statusPacket.params[4] = leftForwardTicksTurns;[m
[32m+[m[32m  statusPacket.params[5] = rightForwardTicksTurns;[m
[32m+[m[32m  statusPacket.params[6] = leftReverseTicksTurns;[m
[32m+[m[32m  statusPacket.params[7] = rightReverseTicksTurns;[m
[32m+[m[32m  statusPacket.params[8] = forwardDist;[m
[32m+[m[32m  statusPacket.params[9] = reverseDist;[m
[32m+[m[32m  sendResponse(&statusPacket);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid sendMessage(const char *message)[m
[32m+[m[32m{[m
[32m+[m[32m  // Sends text messages back to the Pi. Useful[m
[32m+[m[32m  // for debugging.[m
[32m+[m[41m  [m
[32m+[m[32m  TPacket messagePacket;[m
[32m+[m[32m  messagePacket.packetType=PACKET_TYPE_MESSAGE;[m
[32m+[m[32m  strncpy(messagePacket.data, message, MAX_STR_LEN);[m
[32m+[m[32m  sendResponse(&messagePacket);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid dbprintf(char *format, ...) {[m
[32m+[m[32m  va_list args;[m
[32m+[m[32m  char buffer[128];[m
[32m+[m
[32m+[m[32m  va_start(args, format);[m
[32m+[m[32m  vsprintf(buffer, format, args);[m
[32m+[m[32m  sendMessage(buffer);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid sendBadPacket()[m
[32m+[m[32m{[m
[32m+[m[32m  // Tell the Pi that it sent us a packet with a bad[m
[32m+[m[32m  // magic number.[m
[32m+[m[41m  [m
[32m+[m[32m  TPacket badPacket;[m
[32m+[m[32m  badPacket.packetType = PACKET_TYPE_ERROR;[m
[32m+[m[32m  badPacket.command = RESP_BAD_PACKET;[m
[32m+[m[32m  sendResponse(&badPacket);[m
[32m+[m[41m  [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid sendBadChecksum()[m
[32m+[m[32m{[m
[32m+[m[32m  // Tell the Pi that it sent us a packet with a bad[m
[32m+[m[32m  // checksum.[m
[32m+[m[41m  [m
[32m+[m[32m  TPacket badChecksum;[m
[32m+[m[32m  badChecksum.packetType = PACKET_TYPE_ERROR;[m
[32m+[m[32m  badChecksum.command = RESP_BAD_CHECKSUM;[m
[32m+[m[32m  sendResponse(&badChecksum);[m[41m  [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid sendBadCommand()[m
[32m+[m[